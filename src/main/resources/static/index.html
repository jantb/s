<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Log Viewer</title>
    <style>
        body {
            font-family: 'JetBrains Mono', 'Consolas', 'Monaco', monospace;
            margin: 0;
            padding: 0;
            background-color: #1e1e22;
            color: #d4d4d4;
            display: flex;
            flex-direction: column;
            height: 100vh;
            font-size: 12px;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 8px;
            }
            .search-container {
                flex-direction: column;
                gap: 8px;
            }
            .search-wrapper {
                width: 100%;
            }
            .search-options {
                margin-left: 0;
            }
            .level-filters {
                width: 100%;
                overflow-x: auto;
                padding: 4px;
            }
            .buttons {
                width: 100%;
                justify-content: center;
            }
            .pod-modal {
                width: 95%;
            }
        }
        
        @media (max-width: 480px) {
            .header {
                padding: 6px;
            }
            .search-option {
                padding: 2px 6px;
                font-size: 10px;
            }
            .level-filter {
                padding: 2px 6px;
                font-size: 10px;
            }
            .pod-item {
                padding: 8px 12px;
            }
        }
        .header {
            display: flex;
            padding: 8px;
            background-color: #252526;
            border-bottom: 1px solid #3c3c3c;
        }
        .search-container {
            flex: 1;
            margin-right: 8px;
            display: flex;
            gap: 8px;
        }
        .search-wrapper {
            flex: 1;
            position: relative;
        }
        #search-input {
            width: 100%;
            padding: 6px 8px;
            background-color: #3c3c3c;
            border: 1px solid #555;
            color: #d4d4d4;
            font-size: 12px;
            border-radius: 3px;
            box-sizing: border-box;
        }
        .search-options {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: 8px;
        }
        .search-option {
            padding: 4px 8px;
            background-color: #3c3c3c;
            border: 1px solid #555;
            color: #888;
            font-size: 11px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .search-option.active {
            background-color: #0e639c;
            color: white;
            border-color: #0e639c;
        }
        .search-option:hover {
            background-color: #454545;
        }
        .search-option.active:hover {
            background-color: #1177bb;
        }
        .level-filters {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 0 8px;
            background-color: #3c3c3c;
            border: 1px solid #555;
            border-radius: 3px;
        }
        .level-filter {
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.2s ease;
        }
        .level-filter.active {
            opacity: 1;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.3);
        }
        .level-filter.inactive {
            opacity: 0.5;
        }
        .level-filter.INFO {
            background-color: #4CAF50;
            color: white;
        }
        .level-filter.WARN {
            background-color: #FF9800;
            color: white;
        }
        .level-filter.ERROR {
            background-color: #F44336;
            color: white;
        }
        .level-filter.DEBUG {
            background-color: #607D8B;
            color: white;
        }
        .level-filter.KAFKA {
            background-color: #00BCD4;
            color: white;
        }
        .log-viewer {
            flex: 1;
            overflow-y: auto;
            font-size: 11px;
            position: relative;
            overflow-anchor: none;
        }
        .log-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            min-height: 100%;
        }
        .log-line {
            padding: 0 8px;
            border-bottom: 1px solid #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            height: 22px;
            line-height: 22px;
            box-sizing: border-box;
            position: absolute;
            width: 100%;
            left: 0;
            font-size: 11px;
            text-indent: 0;
            margin: 0;
            display: flex;
            align-items: center;
        }
        .timestamp {
            color: #888;
            margin-right: 8px;
            flex-shrink: 0;
        }
        .log-level {
            color: #DDD;
            margin-right: 8px;
            width: 60px;
            text-align: center;
            flex-shrink: 0;
        }
        .log-message {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .pod-selector {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(30, 30, 34, 0.9);
            display: none;
            flex-direction: column;
            padding: 20px;
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .pod-selector.visible {
            display: flex;
        }
        .kafka-topics-selector {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(30, 30, 34, 0.9);
            display: none;
            flex-direction: column;
            padding: 20px;
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .kafka-topics-selector.visible {
            display: flex;
        }
        .log-clusters-selector {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(30, 30, 34, 0.9);
            display: none;
            flex-direction: column;
            padding: 20px;
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .log-clusters-selector.visible {
            display: flex;
        }
        .kafka-lag-selector {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(30, 30, 34, 0.9);
            display: none;
            flex-direction: column;
            padding: 20px;
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .kafka-lag-selector.visible {
            display: flex;
        }
        
        .kafka-lag-modal {
            background-color: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 6px;
            width: calc(100% - 200px);
            height: calc(100% - 200px);
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        .kafka-lag-modal .pod-list {
            flex: 1;
            overflow-y: auto;
            background-color: #1e1e1e;
            max-height: none;
        }
        .pod-modal {
            background-color: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 6px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        .log-clusters-modal {
            background-color: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 6px;
            width: calc(100% - 200px);
            height: calc(100% - 200px);
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        .pod-modal-header {
            padding: 12px 16px;
            border-bottom: 1px solid #3c3c3c;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .pod-modal-title {
            font-size: 14px;
            font-weight: bold;
            color: #d4d4d4;
        }
        .pod-modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 16px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .pod-modal-close:hover {
            color: #d4d4d4;
        }
        .pod-search-container {
            padding: 12px 16px;
            border-bottom: 1px solid #3c3c3c;
        }
        .pod-search {
            width: 100%;
            padding: 8px 12px;
            background-color: #3c3c3c;
            border: 1px solid #555;
            color: #d4d4d4;
            font-size: 12px;
            border-radius: 3px;
            box-sizing: border-box;
        }
        .pod-list {
            flex: 1;
            overflow-y: auto;
            background-color: #1e1e1e;
            max-height: 400px;
        }
        
        .log-clusters-modal .pod-list {
            flex: 1;
            overflow-y: auto;
            background-color: #1e1e1e;
            max-height: none;
        }
        .pod-item {
            padding: 10px 16px;
            border-bottom: 1px solid #3c3c3c;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            transition: background-color 0.1s ease;
        }
        .pod-item:hover {
            background-color: #2a2d2e;
        }
        .pod-item.selected {
            background-color: #094771;
        }
        .pod-item.selected:hover {
            background-color: #0c5a8f;
        }
        .pod-name {
            flex: 1;
            font-weight: 500;
        }
        .pod-version {
            color: #888;
            font-size: 11px;
            margin-left: 8px;
        }
        .pod-checkbox {
            width: 16px;
            height: 16px;
            border: 1px solid #555;
            border-radius: 3px;
            margin-right: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .pod-item.selected .pod-checkbox {
            background-color: #0e639c;
            border-color: #0e639c;
        }
        .pod-checkbox::after {
            content: '';
            width: 10px;
            height: 10px;
            background-color: white;
            display: none;
        }
        .pod-item.selected .pod-checkbox::after {
            display: block;
        }
        .pod-modal-footer {
            padding: 12px 16px;
            border-top: 1px solid #3c3c3c;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        .pod-modal-footer button {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 3px;
            cursor: pointer;
        }
        .pod-modal-footer .btn-primary {
            background-color: #0e639c;
            border: 1px solid #0e639c;
            color: white;
        }
        .pod-modal-footer .btn-primary:hover {
            background-color: #1177bb;
        }
        .pod-modal-footer .btn-secondary {
            background-color: #3c3c3c;
            border: 1px solid #555;
            color: #d4d4d4;
        }
        .pod-modal-footer .btn-secondary:hover {
            background-color: #454545;
        }
        .level-INFO .log-message {
            color: #6A9955 !important;
        }
        .level-WARN .log-message {
            color: #DCDCAA !important;
        }
        .level-ERROR .log-message {
            color: #F14C4C !important;
        }
        .level-DEBUG .log-message {
            color: #9CDCFE !important;
        }
        .level-KAFKA .log-message {
            color: #CE9178 !important;
        }
        .buttons {
            display: flex;
            align-items: center;
        }
        button {
            margin-left: 8px;
            padding: 4px 8px;
            background-color: #0e639c;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 11px;
        }
        button:hover {
            background-color: #1177bb;
        }
        
        /* Chart styles */
        .chart-container {
            padding: 10px;
            border-bottom: 1px solid #3c3c3c;
        }
        
        .chart-canvas {
            width: 100%;
            height: 200px;
            background-color: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
        }
        
        /* Tooltip styles */
        .chart-tooltip {
            position: absolute;
            background-color: rgba(40, 42, 46, 0.9);
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            padding: 8px;
            pointer-events: none;
            font-size: 11px;
            z-index: 1000;
            display: none;
        }
        
        .chart-tooltip-header {
            font-weight: bold;
            margin-bottom: 4px;
            color: #d4d4d4;
        }
        
        .chart-tooltip-item {
            margin-bottom: 2px;
        }
        
        .chart-tooltip-value {
            color: #9cdcfe;
        }
    </style>
</head>
<body>
<div class="header">
    <div class="search-container">
        <div class="search-wrapper">
            <input type="text" class="search-input" id="search-input" placeholder="Search logs...">
        </div>
        <div class="search-options">
            <div class="search-option" id="case-sensitive" title="Case Sensitive (Alt+C)">Aa</div>
            <div class="search-option" id="regex-search" title="Regex Search (Alt+R)">.*</div>
        </div>
        <div class="level-filters" id="level-filters">
            <div class="level-filter INFO active" data-level="INFO">INFO</div>
            <div class="level-filter WARN active" data-level="WARN">WARN</div>
            <div class="level-filter ERROR active" data-level="ERROR">ERROR</div>
            <div class="level-filter DEBUG active" data-level="DEBUG">DEBUG</div>
            <div class="level-filter KAFKA active" data-level="KAFKA">KAFKA</div>
        </div>
    </div>
    <div class="buttons">
        <button id="pod-select-btn">Select Pods</button>
        <button id="kafka-topics-btn">Kafka Topics</button>
        <button id="kafka-lag-btn">Kafka Lag</button>
        <button id="log-clusters-btn">Log Clusters</button>
        <span id="stats-counter" style="margin-left: 12px; color: #9CDCFE; font-size: 11px;">Indexed Lines: 0</span>
        <span id="search-status" style="margin-left: 12px; color: #DCDCAA; font-size: 11px;"></span>
    </div>
</div>
<div class="chart-container">
    <canvas id="log-level-chart" class="chart-canvas"></canvas>
</div>
<div class="log-viewer" id="log-viewer">
    <div class="log-container" id="log-container"></div>
</div>
<div class="chart-tooltip" id="chart-tooltip"></div>
<div class="pod-selector" id="pod-selector">
    <div class="pod-modal">
        <div class="pod-modal-header">
            <div class="pod-modal-title">Select Pods</div>
            <button class="pod-modal-close" id="close-pod-selector-btn">×</button>
        </div>
        <div class="pod-search-container">
            <input type="text" class="pod-search" id="pod-search" placeholder="Filter pods...">
        </div>
        <div class="pod-list" id="pod-list"></div>
        <div class="pod-modal-footer">
            <button class="btn-secondary" id="refresh-pods-btn">Refresh</button>
            <button class="btn-primary" id="apply-pod-selection-btn">Apply</button>
        </div>
    </div>
</div>

<div class="kafka-topics-selector" id="kafka-topics-selector">
    <div class="pod-modal">
        <div class="pod-modal-header">
            <div class="pod-modal-title">Kafka Topics</div>
            <button class="pod-modal-close" id="close-kafka-topics-btn">×</button>
        </div>
        <div class="pod-search-container">
            <input type="text" class="pod-search" id="kafka-topics-search" placeholder="Filter topics...">
        </div>
        <div class="pod-list" id="kafka-topics-list"></div>
        <div class="pod-modal-footer">
            <button class="btn-secondary" id="refresh-kafka-topics-btn">Refresh</button>
            <button class="btn-primary" id="apply-kafka-topics-btn">Apply</button>
        </div>
    </div>
</div>

<div class="log-clusters-selector" id="log-clusters-selector">
    <div class="log-clusters-modal">
        <div class="pod-modal-header">
            <div class="pod-modal-title">Log Clusters</div>
            <button class="pod-modal-close" id="close-log-clusters-btn">×</button>
        </div>
        <div class="chart-container">
            <canvas id="log-clusters-chart" class="chart-canvas"></canvas>
        </div>
        <div class="pod-list" id="log-clusters-list"></div>
    </div>
</div>

<div class="kafka-lag-selector" id="kafka-lag-selector">
    <div class="kafka-lag-modal">
        <div class="pod-modal-header">
            <div class="pod-modal-title">Kafka Consumer Lag</div>
            <button class="pod-modal-close" id="close-kafka-lag-btn">×</button>
        </div>
        <div class="chart-container">
            <canvas id="kafka-lag-chart" class="chart-canvas"></canvas>
        </div>
        <div class="pod-list" id="kafka-lag-list"></div>
        <div class="pod-modal-footer">
            <button class="btn-secondary" id="refresh-kafka-lag-btn">Refresh</button>
        </div>
    </div>
</div>

<script>
    // Virtual scrolling globals
    let selectedPods = new Set();
    let allPods = [];
    let searchQuery = '';
    let allLogs = [];
    let activeLevels = new Set(['INFO', 'WARN', 'ERROR', 'DEBUG', 'KAFKA']);
    let tempSelectedPods = new Set(); // Temporary selection for modal
    let caseSensitive = false;
    let regexSearch = false;
    const lineHeight = 22;
    let viewportHeight = 0;
    let maxVisibleLines = 0;
    let logViewer = null;
    let logContainer = null;
    let isLoading = false;
    let currentOffset = 0;
    let lastSentOffset = -1;

    // Initialize the virtual scrolling
    function initVirtualScroll() {
        logViewer = document.getElementById('log-viewer');
        logContainer = document.getElementById('log-container');

        viewportHeight = logViewer.clientHeight;
        maxVisibleLines = Math.ceil(viewportHeight / lineHeight) -2;

        logViewer.addEventListener('wheel', handleScroll);
        window.addEventListener('resize', () => {
            viewportHeight = logViewer.clientHeight;
            maxVisibleLines = Math.ceil(viewportHeight / lineHeight) -2;
            renderVisibleLogs();
            
            // Resize charts if they exist
            if (logLevelChart && logLevelChart.canvas) {
                resizeCanvas(logLevelChart.canvas);
                drawLogLevelChart();
            }
            if (kafkaLagChart && kafkaLagChart.canvas) {
                resizeCanvas(kafkaLagChart.canvas);
                drawKafkaLagChart();
            }
            if (logClustersChart && logClustersChart.canvas) {
                resizeCanvas(logClustersChart.canvas);
                drawLogClustersChart();
            }
        });

        // Pre-create log line elements
        for (let i = 0; i < maxVisibleLines; i++) {
            const logElement = document.createElement('div');
            logElement.className = 'log-line';
            logElement.style.top = `${i * lineHeight}px`;
            logElement.innerHTML = `
                <span class="timestamp"></span>
                <span class="log-level"></span>
                <span class="log-message"></span>
            `;
            logContainer.appendChild(logElement);
        }

        // Add event listeners for level filters
        document.querySelectorAll('.level-filter').forEach(filter => {
            filter.addEventListener('click', () => {
                const level = filter.dataset.level;
                if (activeLevels.has(level)) {
                    activeLevels.delete(level);
                    filter.classList.remove('active');
                    filter.classList.add('inactive');
                } else {
                    activeLevels.add(level);
                    filter.classList.remove('inactive');
                    filter.classList.add('active');
                }
                // Re-render logs with new filter
                renderVisibleLogs();
                // If we have a search query, re-fetch logs to ensure we have enough matching the filter
                if (searchQuery || activeLevels.size < 5) {
                    fetchLogs(currentOffset);
                }
            });
        });
        
        // Add event listeners for search options
        document.getElementById('case-sensitive').addEventListener('click', () => {
            caseSensitive = !caseSensitive;
            const element = document.getElementById('case-sensitive');
            if (caseSensitive) {
                element.classList.add('active');
            } else {
                element.classList.remove('active');
            }
            // Re-run search with new option
            if (searchQuery) {
                sendSearchQuery(searchQuery);
            }
        });
        
        document.getElementById('regex-search').addEventListener('click', () => {
            regexSearch = !regexSearch;
            const element = document.getElementById('regex-search');
            if (regexSearch) {
                element.classList.add('active');
            } else {
                element.classList.remove('active');
            }
            // Re-run search with new option
            if (searchQuery) {
                sendSearchQuery(searchQuery);
            }
        });
    }

    // Debounce function to limit scroll event frequency
    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    // Handle scroll events
    function handleScroll(event) {
        event.preventDefault();
        const delta = Math.sign(event.deltaY);
        const newOffset = Math.max(0, currentOffset - delta *3);

        if (newOffset !== currentOffset) {
            console.log(`Wheel event: delta=${delta}, newOffset=${newOffset}`);
            currentOffset = newOffset;
            fetchLogs(currentOffset);
            // Update scroll position to keep visual continuity
            logViewer.scrollTop = currentOffset * lineHeight;
        }
    }

    // Render logs within the viewport
    function renderVisibleLogs() {
        const logLines = logContainer.children;

        // Find logs that match active levels
        let visibleLogIndices = [];
        for (let i = currentOffset; i < allLogs.length && visibleLogIndices.length < maxVisibleLines; i++) {
            if (allLogs[i] && activeLevels.has(allLogs[i].level)) {
                visibleLogIndices.push(i);
            }
        }

        // Render visible logs
        for (let i = 0; i < maxVisibleLines; i++) {
            const logElement = logLines[i];
            if (!logElement) continue;

            if (i >= visibleLogIndices.length) {
                logElement.style.display = 'none';
                continue;
            }

            const logIndex = visibleLogIndices[i];
            const log = allLogs[logIndex];
            if (!log) {
                logElement.style.display = 'none';
                continue;
            }

            logElement.style.display = 'flex';
            logElement.className = `log-line level-${log.level}`;
            logElement.style.top = `${i * lineHeight}px`;

            const date = new Date(log.timestamp);
            const timeStr = date.toISOString().replace('T', ' ').substr(0, 19);

            const escapeHtml = (str) => {
                return str
                    .replace(/&/g, '&')
                    .replace(/</g, '<')
                    .replace(/>/g, '>')
                    .replace(/"/g, '"')
                    .replace(/'/g, '\'');
            };

            const timestampSpan = logElement.querySelector('.timestamp');
            const levelSpan = logElement.querySelector('.log-level');
            const messageSpan = logElement.querySelector('.log-message');

            timestampSpan.textContent = `[${timeStr}]`;
            levelSpan.textContent = `[${log.level}]`;
            messageSpan.textContent = escapeHtml(log.message);
        }
    }

    // Fetch logs for the given offset
    function fetchLogs(offset) {
        if (isLoading) {
            console.log('Already fetching logs, skipping');
            return;
        }

        if (offset === lastSentOffset) {
            console.log('Offset already fetched, rendering existing logs');
            renderVisibleLogs();
            return;
        }

        isLoading = true;
        lastSentOffset = offset;
        document.getElementById('search-status').textContent = 'Loading...';
        console.log(`Fetching logs with offset: ${offset}, length: ${maxVisibleLines}`);

        if (!safeSend({
            action: 'search',
            query: searchQuery,
            offset: offset,
            length: maxVisibleLines,
            levels: Array.from(activeLevels)
        })) {
            console.log('Failed to send search query, connection issue');
            document.getElementById('search-status').textContent = 'Connection lost, reconnecting...';
            isLoading = false;
        }
    }

    // WebSocket connection management
    let socket;
    let reconnectInterval = 1000;
    let maxReconnectInterval = 30000;
    let reconnectTimer = null;
    let isConnected = false;
    let pingInterval = null;

    function connectWebSocket() {
        if (socket) {
            socket.onclose = null;
            socket.onerror = null;
            socket.close();
        }

        clearInterval(pingInterval);
        document.getElementById('stats-counter').textContent = `Connecting...`;

        socket = new WebSocket(`ws://${location.host}/logs`);

        socket.onopen = () => {
            console.log('WebSocket connection established');
            isConnected = true;
            reconnectInterval = 1000;

            if (!logViewer) {
                initVirtualScroll();
            }

            if (searchQuery) {
                fetchLogs(currentOffset);
            }

            if (selectedPods.size > 0) {
                safeSend({ action: 'listPods' });
                selectedPods.forEach(pod => {
                    safeSend({
                        action: 'listenPod',
                        podName: pod
                    });
                });
            }

            pingInterval = setInterval(() => {
                if (socket.readyState === WebSocket.OPEN) {
                    safeSend({ action: 'ping' });
                } else {
                    clearInterval(pingInterval);
                }
            }, 10000);

            document.getElementById('stats-counter').textContent = `Connected - waiting for data...`;
            
            // Send sample data for testing
            sendSampleData();
        };
        
        function sendSampleData() {
            // Sample log level chart data
            const sampleChartData = {
                timePoints: [
                    { time: Date.now() - 300000, counts: [10, 5, 2, 5, 1] },
                    { time: Date.now() - 240000, counts: [15, 3, 1, 8, 2] },
                    { time: Date.now() - 180000, counts: [8, 7, 3, 4, 1] },
                    { time: Date.now() - 120000, counts: [12, 4, 2, 6, 3] },
                    { time: Date.now() - 60000, counts: [9, 6, 1, 7, 2] },
                    { time: Date.now(), counts: [11, 5, 3, 5, 1] }
                ],
                levels: ['INFO', 'WARN', 'ERROR', 'DEBUG', 'KAFKA'],
                scaleMax: 20
            };
            
            // Sample log clusters data
            const sampleClusters = [
                { count: 150, level: 'INFO', indexIdentifier: '001', messagePattern: 'User login successful' },
                { count: 75, level: 'WARN', indexIdentifier: '002', messagePattern: 'Database connection slow' },
                { count: 42, level: 'ERROR', indexIdentifier: '003', messagePattern: 'Failed to process request' },
                { count: 30, level: 'DEBUG', indexIdentifier: '004', messagePattern: 'Debug information' },
                { count: 18, level: 'KAFKA', indexIdentifier: '005', messagePattern: 'Kafka message received' }
            ];
            
            // Sample Kafka lag data
            const sampleLagInfo = [
                { groupId: 'group1', topic: 'topic1', partition: 0, currentOffset: 100, endOffset: 150, lag: 50 },
                { groupId: 'group1', topic: 'topic1', partition: 1, currentOffset: 200, endOffset: 220, lag: 20 },
                { groupId: 'group2', topic: 'topic2', partition: 0, currentOffset: 50, endOffset: 80, lag: 30 },
                { groupId: 'group2', topic: 'topic2', partition: 1, currentOffset: 75, endOffset: 90, lag: 15 }
            ];
            
            // Update charts with sample data
            updateLogLevelChart(sampleChartData);
            updateLogClustersChart(sampleClusters);
            updateKafkaLagChart(sampleLagInfo);
        }

        socket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);

                if (data.type === 'logs') {
                    handleLogData(data.logs);
                } else if (data.type === 'pods') {
                    handlePodData(data.podMaps);
                } else if (data.type === 'stats') {
                    updateStats(data);
                } else if (data.type === 'logClusters') {
                    handleLogClusters(data.logClusters);
                } else if (data.type === 'chartData') {
                    handleChartData(data.chartData);
                } else if (data.type === 'topics') {
                    handleTopics(data.topics);
                } else if (data.type === 'lagInfo') {
                    handleLagInfo(data.lagInfo);
                } else if (data.type === 'welcome') {
                    console.log('Welcome message received:', data.logs[0].message);
                }
            } catch (e) {
                console.error('Error parsing message:', e);
            }
        };

        socket.onclose = (event) => {
            console.log(`WebSocket closed: code=${event.code}, reason=${event.reason}`);
            document.getElementById('stats-counter').textContent = `Disconnected - reconnecting...`;
            isConnected = false;
            clearInterval(pingInterval);
            clearTimeout(reconnectTimer);
            reconnectTimer = setTimeout(() => {
                reconnectInterval = Math.min(reconnectInterval * 1.5, maxReconnectInterval);
                connectWebSocket();
            }, reconnectInterval);
        };

        socket.onerror = (error) => {
            console.error('WebSocket error:', error);
            socket.close();
        };
    }

    connectWebSocket();

    function updateStats(stats) {
        document.getElementById('stats-counter').textContent = `Indexed Lines: ${stats.indexedLines}`;
    }

    function safeSend(data) {
        if (!socket || socket.readyState !== WebSocket.OPEN) {
            console.log('Cannot send message, socket not open');
            return false;
        }

        try {
            socket.send(JSON.stringify(data));
            console.log('Sent message:', data);
            return true;
        } catch (e) {
            console.error('Error sending message:', e);
            return false;
        }
    }

    function handleLogData(logs) {
        const searchStatus = document.getElementById('search-status');
        isLoading = false;

        if (logs.length === 0) {
            searchStatus.textContent = `No logs at offset ${currentOffset}`;
            console.log('No logs received');
            allLogs.length = currentOffset; // Clear logs beyond current offset
            renderVisibleLogs();
            return;
        }

        // Replace logs at the current offset
        for (let i = 0; i < logs.length; i++) {
            allLogs[currentOffset + i] = logs[i];
        }

        searchStatus.textContent = `Showing logs from offset ${currentOffset}`;
        console.log(`Received ${logs.length} logs at offset ${currentOffset}, total stored: ${allLogs.filter(x => x).length}`);

        renderVisibleLogs();
    }

    function handlePodData(pods) {
        allPods = pods;
        renderPodList();
    }

    function handleLogClusters(clusters) {
        console.log('Received log clusters:', clusters);
        logClusters = clusters;
        renderLogClustersList();
        updateLogClustersChart(clusters);
    }

    function handleChartData(chartData) {
        console.log('Received chart data:', chartData);
        // TODO: Implement chart visualization
    }

    function handleTopics(topics) {
        console.log('Received topics:', topics);
        // TODO: Implement topic visualization
    }

    function handleLagInfo(lagInfo) {
        console.log('Received lag info:', lagInfo);
        renderLagInfo(lagInfo);
        updateKafkaLagChart(lagInfo);
    }

    function renderPodList() {
        const podList = document.getElementById('pod-list');
        podList.innerHTML = '';

        const filterText = document.getElementById('pod-search').value.toLowerCase();

        const filteredPods = filterText ?
            allPods.filter(pod => pod.name.toLowerCase().includes(filterText)) :
            allPods;

        for (const pod of filteredPods) {
            const podItem = document.createElement('div');
            podItem.className = `pod-item ${tempSelectedPods.has(pod.name) ? 'selected' : ''}`;
            podItem.innerHTML = `
                <div class="pod-checkbox"></div>
                <div class="pod-name">${pod.name}</div>
                <div class="pod-version">${pod.version}</div>
            `;

            podItem.addEventListener('click', () => {
                if (tempSelectedPods.has(pod.name)) {
                    tempSelectedPods.delete(pod.name);
                } else {
                    tempSelectedPods.add(pod.name);
                }
                renderPodList();
            });

            podList.appendChild(podItem);
        }
    }

    document.getElementById('pod-select-btn').addEventListener('click', () => {
        // Copy current selections to temp set when opening modal
        tempSelectedPods = new Set(selectedPods);
        document.getElementById('pod-selector').classList.add('visible');
        safeSend({
            action: 'listPods'
        });
    });

    document.getElementById('close-pod-selector-btn').addEventListener('click', () => {
        document.getElementById('pod-selector').classList.remove('visible');
    });

    document.getElementById('apply-pod-selection-btn').addEventListener('click', () => {
        // Apply temp selections to actual selections
        const podsToUnlisten = [...selectedPods].filter(pod => !tempSelectedPods.has(pod));
        const podsToListen = [...tempSelectedPods].filter(pod => !selectedPods.has(pod));
        
        // Unlisten from pods that were deselected
        podsToUnlisten.forEach(pod => {
            selectedPods.delete(pod);
            safeSend({
                action: 'unlistenPod',
                podName: pod
            });
        });
        
        // Listen to pods that were selected
        podsToListen.forEach(pod => {
            selectedPods.add(pod);
            safeSend({
                action: 'listenPod',
                podName: pod
            });
        });
        
        document.getElementById('pod-selector').classList.remove('visible');
    });

    document.getElementById('refresh-pods-btn').addEventListener('click', () => {
        safeSend({
            action: 'listPods'
        });
    });

    document.getElementById('pod-search').addEventListener('input', () => {
        renderPodList();
    });

    const sendSearchQuery = debounce((query) => {
        console.log(`New search query: ${query}, clearing old logs`);
        document.getElementById('search-status').textContent = 'Searching...';
        allLogs = []; // Clear all existing logs
        currentOffset = 0;
        lastSentOffset = -1;
        logContainer.innerHTML = ''; // Clear UI
        logViewer.scrollTop = 0; // Reset scroll position
        // Re-initialize log lines
        for (let i = 0; i < maxVisibleLines; i++) {
            const logElement = document.createElement('div');
            logElement.className = 'log-line';
            logElement.style.top = `${i * lineHeight}px`;
            logElement.innerHTML = `
                <span class="timestamp"></span>
                <span class="log-level"></span>
                <span class="log-message"></span>
            `;
            logContainer.appendChild(logElement);
        }
        renderVisibleLogs();

        if (!safeSend({
            action: 'search',
            query: query,
            offset: 0,
            length: maxVisibleLines,
            levels: Array.from(activeLevels)
        })) {
            document.getElementById('search-status').textContent = 'Connection lost, reconnecting...';
        }
    }, 300);

    document.getElementById('search-input').addEventListener('input', (e) => {
        searchQuery = e.target.value;
        sendSearchQuery(searchQuery); // Always send the query, even if blank
    });

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
        // Ctrl/Cmd + P to open pod selection
        if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
            e.preventDefault();
            document.getElementById('pod-select-btn').click();
        }
        
        // Escape to close pod selection
        if (e.key === 'Escape') {
            const podSelector = document.getElementById('pod-selector');
            if (podSelector.classList.contains('visible')) {
                podSelector.classList.remove('visible');
            }
        }
        
        // Enter in search input to force search
        if (e.key === 'Enter' && e.target.id === 'search-input') {
            sendSearchQuery(searchQuery);
        }
        
        // Alt + C for case sensitive toggle
        if (e.altKey && e.key === 'c') {
            e.preventDefault();
            document.getElementById('case-sensitive').click();
        }
        
        // Alt + R for regex search toggle
        if (e.altKey && e.key === 'r') {
            e.preventDefault();
            document.getElementById('regex-search').click();
        }
    });

    // Kafka topics functionality
    let allTopics = [];
    let selectedTopics = new Set();

    document.getElementById('kafka-topics-btn').addEventListener('click', () => {
        document.getElementById('kafka-topics-selector').classList.add('visible');
        safeSend({
            action: 'listTopics'
        });
    });

    document.getElementById('close-kafka-topics-btn').addEventListener('click', () => {
        document.getElementById('kafka-topics-selector').classList.remove('visible');
    });

    document.getElementById('refresh-kafka-topics-btn').addEventListener('click', () => {
        safeSend({
            action: 'listTopics'
        });
    });

    document.getElementById('apply-kafka-topics-btn').addEventListener('click', () => {
        // For now, just close the modal
        // In a real implementation, we would apply the topic selection
        document.getElementById('kafka-topics-selector').classList.remove('visible');
    });

    document.getElementById('kafka-topics-search').addEventListener('input', () => {
        renderTopicsList();
    });

    function handleTopics(topics) {
        allTopics = topics;
        renderTopicsList();
    }

    function renderTopicsList() {
        const topicsList = document.getElementById('kafka-topics-list');
        topicsList.innerHTML = '';

        const filterText = document.getElementById('kafka-topics-search').value.toLowerCase();

        const filteredTopics = filterText ?
            allTopics.filter(topic => topic.name.toLowerCase().includes(filterText)) :
            allTopics;

        for (const topic of filteredTopics) {
            const topicItem = document.createElement('div');
            topicItem.className = 'pod-item';
            topicItem.innerHTML = `
                <div class="pod-name">${topic.name}</div>
            `;

            topicItem.addEventListener('click', () => {
                // For now, just log the click
                console.log('Topic clicked:', topic.name);
            });

            topicsList.appendChild(topicItem);
        }
    }

    // Log clusters functionality
    let logClusters = [];

    document.getElementById('log-clusters-btn').addEventListener('click', () => {
        document.getElementById('log-clusters-selector').classList.add('visible');
        // Request log clusters data
        safeSend({
            action: 'refreshLogGroups'
        });
    });

    document.getElementById('close-log-clusters-btn').addEventListener('click', () => {
        document.getElementById('log-clusters-selector').classList.remove('visible');
    });

    function handleLogClusters(clusters) {
        logClusters = clusters;
        renderLogClustersList();
    }

    function renderLogClustersList() {
        const clustersList = document.getElementById('log-clusters-list');
        clustersList.innerHTML = '';

        // Sort log clusters by count in descending order (most to least)
        const sortedClusters = [...logClusters].sort((a, b) => b.count - a.count);

        for (const cluster of sortedClusters) {
            const clusterItem = document.createElement('div');
            clusterItem.className = 'pod-item';
            clusterItem.innerHTML = `
                <div class="pod-name">${cluster.messagePattern}</div>
                <div class="pod-version">${cluster.count} occurrences</div>
            `;

            clusterItem.addEventListener('click', () => {
                // For now, just log the click
                console.log('Cluster clicked:', cluster.messagePattern);
            });

            clustersList.appendChild(clusterItem);
        }
    }

    // Chart data functionality
    function handleChartData(chartData) {
        console.log('Chart data received:', chartData);
        updateLogLevelChart(chartData);
    }

    // Lag info functionality
    function handleLagInfo(lagInfo) {
        console.log('Lag info received:', lagInfo);
        renderLagInfo(lagInfo);
    }
    
    function renderLagInfo(lagInfo) {
        const lagList = document.getElementById('kafka-lag-list');
        lagList.innerHTML = '';
        
        if (lagInfo.length === 0) {
            const noDataItem = document.createElement('div');
            noDataItem.className = 'pod-item';
            noDataItem.textContent = 'No consumer lag information available.';
            lagList.appendChild(noDataItem);
            return;
        }
        
        // Filter out entries with 0 lag
        const nonZeroLagInfo = lagInfo.filter(info => info.lag > 0);
        
        // If all entries have 0 lag, show a message
        if (nonZeroLagInfo.length === 0) {
            const noLagItem = document.createElement('div');
            noLagItem.className = 'pod-item';
            noLagItem.textContent = 'All topics have zero lag.';
            lagList.appendChild(noLagItem);
            return;
        }
        
        // Group lag info by topic
        const topicLags = {};
        nonZeroLagInfo.forEach(info => {
            if (!topicLags[info.topic]) {
                topicLags[info.topic] = [];
            }
            topicLags[info.topic].push(info);
        });
        
        // Create an array of topics with their total lag for sorting
        const topicsWithTotalLag = Object.entries(topicLags).map(([topic, infos]) => {
            const totalLag = infos.reduce((sum, info) => sum + info.lag, 0);
            return { topic, infos, totalLag };
        });
        
        // Sort topics by total lag in descending order (most lag on top)
        topicsWithTotalLag.sort((a, b) => b.totalLag - a.totalLag);
        
        // Render lag info for each topic
        topicsWithTotalLag.forEach(({ topic, infos, totalLag }) => {
            const topicHeader = document.createElement('div');
            topicHeader.className = 'pod-item';
            topicHeader.innerHTML = `<div class="pod-name"><strong>${topic}</strong></div>`;
            lagList.appendChild(topicHeader);
            
            const totalItem = document.createElement('div');
            totalItem.className = 'pod-item';
            totalItem.innerHTML = `<div class="pod-name">Total Lag</div><div class="pod-version">${totalLag}</div>`;
            lagList.appendChild(totalItem);
            
            // Sort partitions by lag in descending order
            const sortedInfos = [...infos].sort((a, b) => b.lag - a.lag);
            
            // Render individual partition info
            sortedInfos.forEach(info => {
                const partitionItem = document.createElement('div');
                partitionItem.className = 'pod-item';
                partitionItem.innerHTML = `
                    <div class="pod-name">Partition ${info.partition}</div>
                    <div class="pod-version">
                        ${info.currentOffset} → ${info.endOffset} (Lag: ${info.lag})
                    </div>
                `;
                lagList.appendChild(partitionItem);
            });
        });
    }
    
    // Kafka lag view functionality
    document.getElementById('kafka-lag-btn').addEventListener('click', () => {
        document.getElementById('kafka-lag-selector').classList.add('visible');
        safeSend({
            action: 'listLag'
        });
    });
    
    document.getElementById('close-kafka-lag-btn').addEventListener('click', () => {
        document.getElementById('kafka-lag-selector').classList.remove('visible');
    });
    
    document.getElementById('refresh-kafka-lag-btn').addEventListener('click', () => {
        safeSend({
            action: 'listLag'
        });
    });
    
    // Add days selection to Kafka topics
    // Add a dropdown for days selection in the Kafka topics modal
    function addDaysSelectionToTopicsModal() {
        const modalHeader = document.querySelector('.kafka-topics-selector .pod-modal-header');
        if (!modalHeader) return;
        
        // Check if days selection already exists
        if (document.getElementById('kafka-days-selection')) return;
        
        const daysContainer = document.createElement('div');
        daysContainer.id = 'kafka-days-selection';
        daysContainer.style.display = 'flex';
        daysContainer.style.alignItems = 'center';
        daysContainer.style.marginLeft = '20px';
        
        const label = document.createElement('span');
        label.textContent = 'Days back: ';
        label.style.marginRight = '8px';
        label.style.color = '#d4d4d4';
        
        const select = document.createElement('select');
        select.id = 'kafka-days-select';
        select.style.padding = '4px 8px';
        select.style.backgroundColor = '#3c3c3c';
        select.style.border = '1px solid #555';
        select.style.color = '#d4d4d4';
        select.style.borderRadius = '3px';
        
        // Add options for days (0-30)
        for (let i = 0; i <= 30; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = i;
            if (i === 1) option.selected = true; // Default to 1 day
            select.appendChild(option);
        }
        
        select.addEventListener('change', (e) => {
            const days = parseInt(e.target.value);
            // Send message to backend to update days
            safeSend({
                action: 'setKafkaDays',
                days: days
            });
        });
        
        daysContainer.appendChild(label);
        daysContainer.appendChild(select);
        modalHeader.appendChild(daysContainer);
    }
    
    // Call this function when the Kafka topics modal is opened
    const originalKafkaTopicsClick = document.getElementById('kafka-topics-btn').onclick;
    document.getElementById('kafka-topics-btn').onclick = function() {
        if (originalKafkaTopicsClick) originalKafkaTopicsClick.apply(this, arguments);
        setTimeout(addDaysSelectionToTopicsModal, 100); // Add after a short delay to ensure DOM is ready
    };
    
    // Chart functionality
    let logLevelChart = null;
    let kafkaLagChart = null;
    let logClustersChart = null;
    let chartTooltip = null;
    
    // Initialize charts when the page loads
    document.addEventListener('DOMContentLoaded', () => {
        chartTooltip = document.getElementById('chart-tooltip');
        initializeLogLevelChart();
    });
    
    // Log Level Chart implementation
    function initializeLogLevelChart() {
        const canvas = document.getElementById('log-level-chart');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        logLevelChart = {
            canvas: canvas,
            ctx: ctx,
            data: [],
            levels: ['INFO', 'WARN', 'ERROR', 'DEBUG', 'KAFKA'],
            levelColors: {
                'INFO': '#4CAF50',
                'WARN': '#FF9800',
                'ERROR': '#F44336',
                'DEBUG': '#607D8B',
                'KAFKA': '#00BCD4'
            },
            scaleMax: 100,
            hoveredBar: null,
            timeFormatter: new Intl.DateTimeFormat('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            })
        };
        
        // Set canvas size
        resizeCanvas(canvas);
        
        // Add event listeners
        canvas.addEventListener('mousemove', handleLogLevelChartMouseMove);
        canvas.addEventListener('mouseout', handleLogLevelChartMouseOut);
        canvas.addEventListener('click', handleLogLevelChartClick);
        
        // Draw initial empty chart
        drawLogLevelChart();
    }
    
    function resizeCanvas(canvas) {
        const displayWidth = canvas.clientWidth;
        const displayHeight = canvas.clientHeight;
        
        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
            canvas.width = displayWidth;
            canvas.height = displayHeight;
        }
    }
    
    function drawLogLevelChart() {
        if (!logLevelChart) return;
        
        const { ctx, canvas, data, levels, levelColors, scaleMax } = logLevelChart;
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Set background
        ctx.fillStyle = '#252526';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // If no data, show message
        if (data.length === 0) {
            ctx.fillStyle = '#d4d4d4';
            ctx.font = '14px JetBrains Mono';
            ctx.textAlign = 'center';
            ctx.fillText('No chart data available', canvas.width / 2, canvas.height / 2);
            return;
        }
        
        // Chart dimensions
        const margin = { top: 30, right: 20, bottom: 40, left: 50 };
        const chartWidth = canvas.width - margin.left - margin.right;
        const chartHeight = canvas.height - margin.top - margin.bottom;
        
        // Draw grid lines and labels
        ctx.strokeStyle = '#3c3c3c';
        ctx.lineWidth = 1;
        ctx.font = '10px JetBrains Mono';
        ctx.textAlign = 'right';
        ctx.fillStyle = '#d4d4d4';
        
        // Y-axis grid lines and labels
        for (let i = 0; i <= 5; i++) {
            const y = margin.top + chartHeight - (i * chartHeight / 5);
            ctx.beginPath();
            ctx.moveTo(margin.left, y);
            ctx.lineTo(canvas.width - margin.right, y);
            ctx.stroke();
            
            const value = Math.round(scaleMax * i / 5);
            ctx.fillText(value.toString(), margin.left - 10, y + 4);
        }
        
        // X-axis labels
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        const timeSlotWidth = chartWidth / Math.max(1, data.length);
        
        for (let i = 0; i < data.length; i += Math.max(1, Math.floor(data.length / 10))) {
            const x = margin.left + (i * timeSlotWidth) + (timeSlotWidth / 2);
            const timeStr = logLevelChart.timeFormatter.format(data[i].time);
            ctx.fillText(timeStr, x, margin.top + chartHeight + 5);
        }
        
        // Draw bars
        const barWidth = Math.max(1, timeSlotWidth - 2);
        
        for (let i = 0; i < data.length; i++) {
            const x = margin.left + (i * timeSlotWidth);
            let currentHeight = 0;
            
            // Draw bars for each level (stacked)
            for (const level of levels) {
                if (activeLevels.has(level)) {
                    const count = data[i].counts[level] || 0;
                    if (count > 0) {
                        const barHeight = Math.max(1, (count / scaleMax) * chartHeight);
                        const y = margin.top + chartHeight - currentHeight - barHeight;
                        
                        // Draw bar
                        ctx.fillStyle = levelColors[level];
                        ctx.fillRect(x, y, barWidth, barHeight);
                        
                        currentHeight += barHeight;
                    }
                }
            }
        }
        
        // Draw axes
        ctx.strokeStyle = '#d4d4d4';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(margin.left, margin.top);
        ctx.lineTo(margin.left, margin.top + chartHeight);
        ctx.lineTo(canvas.width - margin.right, margin.top + chartHeight);
        ctx.stroke();
        
        // Draw legend
        drawLogLevelChartLegend();
    }
    
    function drawLogLevelChartLegend() {
        if (!logLevelChart) return;
        
        const { ctx, canvas, levels, levelColors } = logLevelChart;
        const legendY = 15;
        const labelWidth = 80;
        const totalWidth = labelWidth * activeLevels.size;
        const startX = (canvas.width - totalWidth) / 2;
        
        ctx.font = '11px JetBrains Mono';
        ctx.textAlign = 'left';
        
        let index = 0;
        for (const level of levels) {
            if (activeLevels.has(level)) {
                const x = startX + (index * labelWidth);
                
                // Draw color box
                ctx.fillStyle = levelColors[level];
                ctx.fillRect(x, legendY - 8, 12, 12);
                
                // Draw level name
                ctx.fillStyle = '#d4d4d4';
                ctx.fillText(level, x + 18, legendY);
                
                index++;
            }
        }
    }
    
    function handleLogLevelChartMouseMove(e) {
        if (!logLevelChart || logLevelChart.data.length === 0) return;
        
        const { canvas, data, levels } = logLevelChart;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Chart dimensions
        const margin = { top: 30, right: 20, bottom: 40, left: 50 };
        const chartWidth = canvas.width - margin.left - margin.right;
        const chartHeight = canvas.height - margin.top - margin.bottom;
        
        // Check if mouse is over chart area
        if (x < margin.left || x > canvas.width - margin.right ||
            y < margin.top || y > margin.top + chartHeight) {
            logLevelChart.hoveredBar = null;
            hideChartTooltip();
            return;
        }
        
        // Calculate which time slot is hovered
        const timeSlotWidth = chartWidth / Math.max(1, data.length);
        const timeIndex = Math.floor((x - margin.left) / timeSlotWidth);
        
        if (timeIndex >= 0 && timeIndex < data.length) {
            const timePoint = data[timeIndex];
            const barX = margin.left + (timeIndex * timeSlotWidth);
            
            // Calculate which level bar is hovered
            let currentHeight = 0;
            let hoveredLevel = null;
            let levelHeight = 0;
            
            // Go through levels in reverse order (top to bottom)
            for (const level of [...levels].reverse()) {
                if (activeLevels.has(level)) {
                    const count = timePoint.counts[level] || 0;
                    if (count > 0) {
                        const barHeight = Math.max(1, (count / logLevelChart.scaleMax) * chartHeight);
                        const barY = margin.top + chartHeight - currentHeight - barHeight;
                        
                        // Check if mouse is over this bar
                        if (y >= barY && y <= barY + barHeight) {
                            hoveredLevel = level;
                            levelHeight = barHeight;
                            break;
                        }
                        
                        currentHeight += barHeight;
                    }
                }
            }
            
            if (hoveredLevel) {
                logLevelChart.hoveredBar = { timeIndex, level: hoveredLevel };
                showLogLevelChartTooltip(timePoint, hoveredLevel, x, y);
            } else {
                logLevelChart.hoveredBar = null;
                hideChartTooltip();
            }
        } else {
            logLevelChart.hoveredBar = null;
            hideChartTooltip();
        }
    }
    
    function handleLogLevelChartMouseOut() {
        if (logLevelChart) {
            logLevelChart.hoveredBar = null;
            hideChartTooltip();
        }
    }
    
    function handleLogLevelChartClick(e) {
        if (!logLevelChart || !logLevelChart.hoveredBar) return;
        
        // Handle click-to-navigate functionality
        // This would typically update the log view to show logs from the selected time period
        console.log('Chart bar clicked:', logLevelChart.hoveredBar);
    }
    
    function showLogLevelChartTooltip(timePoint, level, x, y) {
        if (!chartTooltip) return;
        
        const count = timePoint.counts[level] || 0;
        const total = Object.values(timePoint.counts).reduce((sum, val) => sum + val, 0);
        const percentage = total > 0 ? ((count / total) * 100).toFixed(1) : '0.0';
        
        const timeStr = logLevelChart.timeFormatter.format(timePoint.time);
        
        chartTooltip.innerHTML = `
            <div class="chart-tooltip-header">${timeStr}</div>
            <div class="chart-tooltip-item">
                <span style="color: ${logLevelChart.levelColors[level]}">${level}:</span>
                <span class="chart-tooltip-value">${count}</span>
            </div>
            <div class="chart-tooltip-item">
                <span>Percentage:</span>
                <span class="chart-tooltip-value">${percentage}%</span>
            </div>
            <div class="chart-tooltip-item">
                <span>Total:</span>
                <span class="chart-tooltip-value">${total}</span>
            </div>
        `;
        
        // Position tooltip
        chartTooltip.style.display = 'block';
        chartTooltip.style.left = (x + 10) + 'px';
        chartTooltip.style.top = (y - 10 - chartTooltip.offsetHeight) + 'px';
    }
    
    function hideChartTooltip() {
        if (chartTooltip) {
            chartTooltip.style.display = 'none';
        }
    }
    
    // Update the log level chart with new data
    function updateLogLevelChart(chartData) {
        if (!logLevelChart) return;
        
        // Convert chart data to our format
        logLevelChart.data = chartData.timePoints.map(point => ({
            time: new Date(point.time),
            counts: {}
        }));
        
        // Populate counts for each level
        chartData.timePoints.forEach((point, index) => {
            chartData.levels.forEach((level, levelIndex) => {
                logLevelChart.data[index].counts[level] = point.counts[levelIndex] || 0;
            });
        });
        
        logLevelChart.scaleMax = chartData.scaleMax;
        
        // Redraw chart
        drawLogLevelChart();
    }
    
    // Handle chart data from WebSocket
    function handleChartData(chartData) {
        console.log('Chart data received:', chartData);
        updateLogLevelChart(chartData);
    }
    
    // Kafka Lag Chart implementation
    function initializeKafkaLagChart() {
        const canvas = document.getElementById('kafka-lag-chart');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        kafkaLagChart = {
            canvas: canvas,
            ctx: ctx,
            data: [],
            hideZeroLag: false,
            hoveredBar: null
        };
        
        // Set canvas size
        resizeCanvas(canvas);
        
        // Add event listeners
        canvas.addEventListener('mousemove', handleKafkaLagChartMouseMove);
        canvas.addEventListener('mouseout', handleKafkaLagChartMouseOut);
        
        // Draw initial empty chart
        drawKafkaLagChart();
    }
    
    function drawKafkaLagChart() {
        if (!kafkaLagChart) return;
        
        const { ctx, canvas, data, hideZeroLag } = kafkaLagChart;
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Set background
        ctx.fillStyle = '#252526';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Filter data if needed
        const filteredData = hideZeroLag ? data.filter(item => item.lag > 0) : data;
        
        // If no data, show message
        if (filteredData.length === 0) {
            ctx.fillStyle = '#d4d4d4';
            ctx.font = '14px JetBrains Mono';
            ctx.textAlign = 'center';
            ctx.fillText('No lag data available', canvas.width / 2, canvas.height / 2);
            return;
        }
        
        // Chart dimensions
        const margin = { top: 30, right: 20, bottom: 40, left: 50 };
        const chartWidth = canvas.width - margin.left - margin.right;
        const chartHeight = canvas.height - margin.top - margin.bottom;
        
        // Find max lag for scaling
        const maxLag = Math.max(...filteredData.map(item => item.lag), 1);
        
        // Draw bars
        const barWidth = Math.max(2, chartWidth / Math.max(1, filteredData.length) - 4);
        const barSpacing = 4;
        
        ctx.font = '10px JetBrains Mono';
        ctx.textAlign = 'center';
        
        for (let i = 0; i < filteredData.length; i++) {
            const item = filteredData[i];
            const x = margin.left + (i * (barWidth + barSpacing));
            const barHeight = Math.max(1, (item.lag / maxLag) * chartHeight);
            const y = margin.top + chartHeight - barHeight;
            
            // Draw bar
            ctx.fillStyle = '#F44336'; // Red color for lag
            ctx.fillRect(x, y, barWidth, barHeight);
            
            // Draw topic name (truncated if too long)
            const topicLabel = item.topic.length > 15 ? item.topic.substring(0, 12) + '...' : item.topic;
            ctx.fillStyle = '#d4d4d4';
            ctx.fillText(topicLabel, x + barWidth / 2, margin.top + chartHeight + 15);
            
            // Draw lag value
            ctx.fillText(item.lag.toString(), x + barWidth / 2, y - 5);
        }
        
        // Draw axes
        ctx.strokeStyle = '#d4d4d4';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(margin.left, margin.top);
        ctx.lineTo(margin.left, margin.top + chartHeight);
        ctx.lineTo(canvas.width - margin.right, margin.top + chartHeight);
        ctx.stroke();
        
        // Draw title
        ctx.fillStyle = '#d4d4d4';
        ctx.font = '12px JetBrains Mono';
        ctx.textAlign = 'left';
        ctx.fillText('Kafka Consumer Lag by Topic', margin.left, margin.top - 10);
    }
    
    function handleKafkaLagChartMouseMove(e) {
        if (!kafkaLagChart || kafkaLagChart.data.length === 0) return;
        
        const { canvas, data } = kafkaLagChart;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Chart dimensions
        const margin = { top: 30, right: 20, bottom: 40, left: 50 };
        const chartWidth = canvas.width - margin.left - margin.right;
        const chartHeight = canvas.height - margin.top - margin.bottom;
        
        // Check if mouse is over chart area
        if (x < margin.left || x > canvas.width - margin.right ||
            y < margin.top || y > margin.top + chartHeight) {
            kafkaLagChart.hoveredBar = null;
            hideChartTooltip();
            return;
        }
        
        // Find which bar is hovered
        const filteredData = kafkaLagChart.hideZeroLag ? data.filter(item => item.lag > 0) : data;
        const barWidth = Math.max(2, chartWidth / Math.max(1, filteredData.length) - 4);
        const barSpacing = 4;
        
        for (let i = 0; i < filteredData.length; i++) {
            const item = filteredData[i];
            const barX = margin.left + (i * (barWidth + barSpacing));
            
            // Check if mouse is over this bar
            if (x >= barX && x <= barX + barWidth) {
                kafkaLagChart.hoveredBar = i;
                showKafkaLagChartTooltip(item, x, y);
                return;
            }
        }
        
        kafkaLagChart.hoveredBar = null;
        hideChartTooltip();
    }
    
    function handleKafkaLagChartMouseOut() {
        if (kafkaLagChart) {
            kafkaLagChart.hoveredBar = null;
            hideChartTooltip();
        }
    }
    
    function showKafkaLagChartTooltip(item, x, y) {
        if (!chartTooltip) return;
        
        chartTooltip.innerHTML = `
            <div class="chart-tooltip-header">${item.topic}</div>
            <div class="chart-tooltip-item">
                <span>Lag:</span>
                <span class="chart-tooltip-value">${item.lag}</span>
            </div>
            <div class="chart-tooltip-item">
                <span>Group ID:</span>
                <span class="chart-tooltip-value">${item.groupId}</span>
            </div>
            <div class="chart-tooltip-item">
                <span>Partition:</span>
                <span class="chart-tooltip-value">${item.partition}</span>
            </div>
        `;
        
        // Position tooltip
        chartTooltip.style.display = 'block';
        chartTooltip.style.left = (x + 10) + 'px';
        chartTooltip.style.top = (y - 10 - chartTooltip.offsetHeight) + 'px';
    }
    
    // Update the Kafka lag chart with new data
    function updateKafkaLagChart(lagInfo) {
        if (!kafkaLagChart) {
            // Initialize chart if not already done
            initializeKafkaLagChart();
        }
        
        // Aggregate lag info by topic
        const topicLags = {};
        lagInfo.forEach(info => {
            if (!topicLags[info.topic]) {
                topicLags[info.topic] = {
                    topic: info.topic,
                    groupId: info.groupId,
                    partition: info.partition,
                    lag: 0
                };
            }
            topicLags[info.topic].lag += info.lag;
        });
        
        kafkaLagChart.data = Object.values(topicLags);
        
        // Redraw chart
        drawKafkaLagChart();
    }
    
    // Log Clusters Chart implementation
    function initializeLogClustersChart() {
        const canvas = document.getElementById('log-clusters-chart');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        logClustersChart = {
            canvas: canvas,
            ctx: ctx,
            data: [],
            hideLowSeverity: false,
            hoveredBar: null
        };
        
        // Set canvas size
        resizeCanvas(canvas);
        
        // Add event listeners
        canvas.addEventListener('mousemove', handleLogClustersChartMouseMove);
        canvas.addEventListener('mouseout', handleLogClustersChartMouseOut);
        
        // Draw initial empty chart
        drawLogClustersChart();
    }
    
    function drawLogClustersChart() {
        if (!logClustersChart) return;
        
        const { ctx, canvas, data, hideLowSeverity } = logClustersChart;
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Set background
        ctx.fillStyle = '#252526';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Filter data if needed
        let filteredData = data;
        if (hideLowSeverity) {
            filteredData = data.filter(item =>
                item.level !== 'DEBUG' && item.level !== 'INFO' && item.level !== 'UNKNOWN'
            );
        }
        
        // Sort by count descending
        const sortedData = [...filteredData].sort((a, b) => b.count - a.count);
        
        // If no data, show message
        if (sortedData.length === 0) {
            ctx.fillStyle = '#d4d4d4';
            ctx.font = '14px JetBrains Mono';
            ctx.textAlign = 'center';
            ctx.fillText('No cluster data available', canvas.width / 2, canvas.height / 2);
            return;
        }
        
        // Chart dimensions
        const margin = { top: 30, right: 20, bottom: 40, left: 50 };
        const chartWidth = canvas.width - margin.left - margin.right;
        const chartHeight = canvas.height - margin.top - margin.bottom;
        
        // Find max count for scaling
        const maxCount = Math.max(...sortedData.map(item => item.count), 1);
        
        // Draw bars
        const barWidth = Math.max(2, chartWidth / Math.max(1, sortedData.length) - 4);
        const barSpacing = 4;
        
        ctx.font = '10px JetBrains Mono';
        ctx.textAlign = 'center';
        
        for (let i = 0; i < sortedData.length; i++) {
            const item = sortedData[i];
            const x = margin.left + (i * (barWidth + barSpacing));
            const barHeight = Math.max(1, (item.count / maxCount) * chartHeight);
            const y = margin.top + chartHeight - barHeight;
            
            // Get color based on level
            const color = getLevelColor(item.level);
            
            // Draw bar
            ctx.fillStyle = color;
            ctx.fillRect(x, y, barWidth, barHeight);
            
            // Draw cluster pattern (truncated if too long)
            const patternLabel = item.messagePattern.length > 15 ?
                item.messagePattern.substring(0, 12) + '...' : item.messagePattern;
            ctx.fillStyle = '#d4d4d4';
            ctx.fillText(patternLabel, x + barWidth / 2, margin.top + chartHeight + 15);
            
            // Draw count
            ctx.fillText(item.count.toString(), x + barWidth / 2, y - 5);
        }
        
        // Draw axes
        ctx.strokeStyle = '#d4d4d4';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(margin.left, margin.top);
        ctx.lineTo(margin.left, margin.top + chartHeight);
        ctx.lineTo(canvas.width - margin.right, margin.top + chartHeight);
        ctx.stroke();
        
        // Draw title
        ctx.fillStyle = '#d4d4d4';
        ctx.font = '12px JetBrains Mono';
        ctx.textAlign = 'left';
        ctx.fillText('Log Cluster Distribution by Level', margin.left, margin.top - 10);
    }
    
    function getLevelColor(level) {
        const levelColors = {
            'INFO': '#4CAF50',
            'WARN': '#FF9800',
            'ERROR': '#F44336',
            'DEBUG': '#607D8B',
            'KAFKA': '#00BCD4',
            'UNKNOWN': '#9E9E9E'
        };
        return levelColors[level] || '#d4d4d4';
    }
    
    function handleLogClustersChartMouseMove(e) {
        if (!logClustersChart || logClustersChart.data.length === 0) return;
        
        const { canvas, data } = logClustersChart;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Chart dimensions
        const margin = { top: 30, right: 20, bottom: 40, left: 50 };
        const chartWidth = canvas.width - margin.left - margin.right;
        const chartHeight = canvas.height - margin.top - margin.bottom;
        
        // Check if mouse is over chart area
        if (x < margin.left || x > canvas.width - margin.right ||
            y < margin.top || y > margin.top + chartHeight) {
            logClustersChart.hoveredBar = null;
            hideChartTooltip();
            return;
        }
        
        // Find which bar is hovered
        let filteredData = data;
        if (logClustersChart.hideLowSeverity) {
            filteredData = data.filter(item =>
                item.level !== 'DEBUG' && item.level !== 'INFO' && item.level !== 'UNKNOWN'
            );
        }
        
        // Sort by count descending
        const sortedData = [...filteredData].sort((a, b) => b.count - a.count);
        
        const barWidth = Math.max(2, chartWidth / Math.max(1, sortedData.length) - 4);
        const barSpacing = 4;
        
        for (let i = 0; i < sortedData.length; i++) {
            const item = sortedData[i];
            const barX = margin.left + (i * (barWidth + barSpacing));
            
            // Check if mouse is over this bar
            if (x >= barX && x <= barX + barWidth) {
                logClustersChart.hoveredBar = i;
                showLogClustersChartTooltip(item, x, y);
                return;
            }
        }
        
        logClustersChart.hoveredBar = null;
        hideChartTooltip();
    }
    
    function handleLogClustersChartMouseOut() {
        if (logClustersChart) {
            logClustersChart.hoveredBar = null;
            hideChartTooltip();
        }
    }
    
    function showLogClustersChartTooltip(item, x, y) {
        if (!chartTooltip) return;
        
        chartTooltip.innerHTML = `
            <div class="chart-tooltip-header">${item.level}</div>
            <div class="chart-tooltip-item">
                <span>Count:</span>
                <span class="chart-tooltip-value">${item.count}</span>
            </div>
            <div class="chart-tooltip-item">
                <span>Pattern:</span>
                <span class="chart-tooltip-value">${item.messagePattern}</span>
            </div>
        `;
        
        // Position tooltip
        chartTooltip.style.display = 'block';
        chartTooltip.style.left = (x + 10) + 'px';
        chartTooltip.style.top = (y - 10 - chartTooltip.offsetHeight) + 'px';
    }
    
    // Update the log clusters chart with new data
    function updateLogClustersChart(clusters) {
        if (!logClustersChart) {
            // Initialize chart if not already done
            initializeLogClustersChart();
        }
        
        logClustersChart.data = clusters;
        
        // Redraw chart
        drawLogClustersChart();
    }
    
    // Override the existing handleLagInfo function to update the chart
    const originalHandleLagInfo = handleLagInfo;
    function handleLagInfo(lagInfo) {
        // Call original function
        originalHandleLagInfo(lagInfo);
        
        // Update chart
        updateKafkaLagChart(lagInfo);
    }
    
    // Override the existing handleLogClusters function to update the chart
    const originalHandleLogClusters = handleLogClusters;
    function handleLogClusters(clusters) {
        // Call original function
        originalHandleLogClusters(clusters);
        
        // Update chart
        updateLogClustersChart(clusters);
    }
    
    // Add event listeners for chart initialization when modals are opened
    document.getElementById('kafka-lag-btn').addEventListener('click', () => {
        setTimeout(() => {
            if (!kafkaLagChart) {
                initializeKafkaLagChart();
            }
        }, 100);
    });
    
    document.getElementById('log-clusters-btn').addEventListener('click', () => {
        setTimeout(() => {
            if (!logClustersChart) {
                initializeLogClustersChart();
            }
        }, 100);
    });
</script>
</body>
</html>